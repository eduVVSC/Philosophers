Functions allowed:

- Gettimeofday()
- pthread_create(), This function is going to create my thread and attribuite to it it's 
		behaviour.
- pthread_detach()
- pthread_join(), This function will bascally make the threads run;
-----------------------------------------------------------
- pthread_mutex_init(mutex adress, Initializer), It will initialize the protected objects,
						 with default values;
- pthread_mutex_deatroy(mutex adress), It will destroy the protected objects, releasing the 
						memory;
- pthread_mutex_lock(mutex adress), it locks the mutex;
- pthread_mutex_unlock(mutex adress),  it unlocks the mutex;

	The mutex are going to be needed to protect the forks on the table.Type of mutexes:
	-PTHREAD_MUTEX_DEFAULT/NORMAL, gives deadlock when tries to lock it a second time, 
				without unlocking it.
	-PTHREAD_MUTEX_ERRORCHECK, avoid deadlocks, return a non-zero value when he tries to 
				to lock the same mutex more than once;
	-PTHREAD_MUTEX_RECURSIVE, it locks and unlocks the same pthread, so it can use than
				free so others can use it. 

deadlock and locks:
A lock happens when multiple processes try to access the same resource at the same time, and a
deadlock is when one of this processes is waiting for the one that is happening now ends, so 
it will release the resource that it's using, so the new one can use it and starts.
 
How it locks, and why:
When we create a mutex, it is already unclocked. When you try to lock an already locked mutex,
the subroutine will block the process that is trying to lock it, until it's unlocked by the
process that is using it at that moment.
When the process that it's using the mutex ends it's needed to unlock it, when unlocking it,
if somehow you try to do it, the mutex is already unolcked, it will return an ERROR. Another 
situation taht change things is if the mutex is being used by another process, depending on 
the type of process is being used, it can unlock it or return ERROR(not recomended to do this)

Why we use it to the forks:
Specifically because we need to protect it of being used more than once at the same time,
because when one philosopher is eatin, he is going to use one fork more than his, so if the 
philosopher close to him wants to eat as well, he is going to need to wait for the other one
finish, so he can start. This process will happen by when a philosopher is going to start 
eating he is going to try to lock both forks, if he can means that he can start eating, other
wise, he needs to wait for the liberation of the other fork.



	Threads:

Threads is a way to execute programs/functions in "parallel" to each other. The function
	-PTHREAD_CREATE(pointer to thread, atribuites of thread, function to run, arguments 
to function) is going to start an execution of a function in a separated thread from
the original part of the program.
	-PTHREAD_JOIN(thread, pointer to NULL), is going to join it to main function, and
start running;
	-PTHREAD_DETACH(thread), is the "free" of the threads, it release the resource back
to the system. If you try to detach/release an already released memory it will give  





Now at the code:

	Now what i need to do is to start the loop in the philophers thread, this loops will 
	be their "life circle", they will sleep, eat and think, so in order to make it, I will
	create their threads and pass te function philo_life:

My philo routine can only receive one void parameter:


Philo life has:
	-sleeping, this function will basecally wait until the diference is iqual to the 
	time of sleep stablished in the entrence;
	-












The ones that i already know:
- memset, printf, malloc, free, write, usleep;














